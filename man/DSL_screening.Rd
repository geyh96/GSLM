% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DSL.R
\name{DSL_screening}
\alias{DSL_screening}
\title{The function implement the kappa selection procedure and the variable selection procedure following the paper.}
\usage{
DSL_screening(
  X,
  Y,
  Loss = "L2",
  lambdas = 10^(seq(-3, 1, 0.3)),
  Tau = 0.5,
  Kernel = "Gaussian",
  Kappa_time = 10,
  Kappa_thres = 10^(seq(-6, 0, 0.1)),
  Kappa_ratio = 1,
  Kappa_multiplier = sqrt(2),
  isKernelScale = FALSE,
  only_gradient = TRUE
)
}
\arguments{
\item{X}{is the covariates matrix.}

\item{Y}{is the response vector.}

\item{Loss}{the loss choosed among L2 Check Huber Logistic SVM-Classification}

\item{lambdas}{is the tunable parameter of RKHS ridge penalty.}

\item{Tau}{is the quantile level we choose. tau = 0.5 by default. for other loss, tau is useless.}

\item{Kernel}{only Gaussian Kernel supported now.}

\item{Kappa_time}{the number of stability selection loop}

\item{Kappa_thres}{the candidates of threshold selected for variable selection}

\item{Kappa_ratio}{the alpha suggested in  the step 4 of algorithm from Sun 2013.}

\item{Kappa_multiplier}{the actually used is the selected threshold times Kappa_multiplier. Suggest by the Sun 2013}

\item{isKernelScale}{parameter for generating the kernel matrix deployed by the kernlab package. default FALSE and the performance is satisfactory.}

\item{only_gradient}{a logic value to decide return a list of gradient or more information}
}
\description{
The function implement the kappa selection procedure and the variable selection procedure following the paper.
}
\examples{
run.n=500
run.p=1000
run.rho=0
if(1){
     UW <- matrix(runif(run.n * run.p, -0.5, 0.5), run.n, run.p)
     VW <- matrix(runif(run.n,  -0.5, 0.5), run.n, 1)
     x <- (UW + run.rho * VW \%x\% t(rep(1, run.p))) / (1 + run.rho)
     y0=4*(x[,1] - x[,2] + x[,3] - x[,4] ) - 6*(x[,1]*x[,2] + x[,2]*x[,3] - x[,3]*x[,4] )
     y=y0 + rnorm(run.n, 0, 1)
   }

print("Begin DSL1")
DSL_result1_screening =  GSLM::DSL_screening(
            x, 
            y,
            Loss = "L2", 
            lambdas = 1e-5,  
            Tau = 0.5, 
            Kernel = "Gaussian",
            Kappa_time=10,
            Kappa_thres = 10^seq(-4,0,0.1))
rank(DSL_result1_screening$measure)[1:5]
Ind1 = which(unname(DSL_result1_screening$screening_result)==1)
iselected_DSL1=Ind1
print('which(Ind1==1)')
print(Ind1)   
    # Ind1=c(1,2,3,4,5)
if(length(Ind1)>1){
###########################################begin KappaInteraction
Kappa_result1 = GSLM::Kappa_DSL2(
                x,
                y,
                Ind1,
                isStrongHeredity = TRUE,
                isInteraction = TRUE,
                Loss = "L2",
                kappa_Tau = 0.5,
                lambdas = 10^seq(-5,0,1),
                Kernel = "Gaussian",
                kappa_time = 10 ,
                kappa_thres =10^seq(-4,1.5,0.1),
                d_kapparatio = 1,
                isKernelScale = FALSE)
names(Kappa_result1)
Kappa_result1$Lambda_Selected
Kappa_result1$Thres_Selected
DSL_result1_interaction = GSLM::DSL_base_order2(
        x, 
        y, 
        isStrongHeredity = TRUE,
        Loss = "L2",
        lambda = Kappa_result1$Lambda_Selected,
        Tau = 0.5,
        Ind = Ind1,
        Kernel ="Gaussian",
        isKernelScale=FALSE,
        print_loss=TRUE
            )$gradient_mat_interaction
iselected2_DSL1  = GSLM::get_order2_vec(DSL_result1_interaction>Kappa_result1$Thres_Selected)
}
print(iselected2_DSL1)
}
